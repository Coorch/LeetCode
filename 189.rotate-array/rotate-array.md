### 题目描述
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

#### 示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

#### 示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

#### 说明:

    尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
    要求使用空间复杂度为 O(1) 的 原地 算法。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 解法
#### 0、每次只向右移动1个位置，循环k次
每次循环：从nums[0]开始，一直到最后一个元素，每次互换nums[0]与nums[i]的值即可
```Python
for i in range(k):
    for j in range(1, len(nums)):
        a = nums[0];
        nums[0] = nums[j];
        nums[j] = a;
```
- 时间复杂度为O(k*len(nums))
- 空间复杂度为O(1)
- 当nums长度很大时，耗时很久，提交LeetCode显示超时，所以此方法不行。

##### 0的改进版
把k处理一下，因为循环len(nums)次得到的还是原来的数组，就把k对n取余。
- 时间复杂度为O($n^2$)
- 空间复杂度为O(1)
- 解决了k的问题，但是没解决n过大的情况，所以提交还是不行。

#### 0.1、直接用Python数组的切片功能
- k对n取余
- nums[:] = nums[-k:] + nums[0:-k]
- 时间复杂度
- 空间复杂度貌似不是1，相当于重新建了一个新的数组

#### 1、环状替换
- k对n取余
- 从start=0开始,当前索引current从start开始,替换的索引next=(current+k)%n
- 类似排座位，第一位同学坐到第k+1位同学的位子上，第k+1被挤开，他就去坐第2k+1位同学的位子，重复；
- 有可能会出现某位同学坐到第一位同学的位子上，此时可能所有同学的位子没有交换完，用count计数交换次数，为n交换完毕。
- 不为n的话，此时没有同学被挤走，所以顺着让第二位同学去坐第k+2位同学的位子
```Python
start = 0
count = 0
while count < n:
    current = start
    prev = nums[start]
    next = (current + k) % n
    temp = nums[next]
    nums[next] = prev
    prev = temp
    count += 1
    current = next
    while current != start:
        next = (current + k) % n
        temp = nums[next]
        nums[next] = prev
        prev = temp
        count += 1
        current = next
    start += 1
```
**思考：为什么在count=n的时候正好跳出了第二层循环？**
- 时间复杂度O(n)
- 空间复杂度O(1)

#### 反转
k=k%n
移动k的结果就是后k个元素按照原来的元素移动到头部，而前n-k个元素向后移动。
所以，可以理解为三次反转：
- 整个数组反转
- 前k个元素反转
- 后n-k个元素反转
比如，n=7,k=3,[1,2,3,4,5,6,7]
- 整个数组反转：[7,6,5,4,3,2,1]
- 前k个元素反转：[5,6,7,4,3,2,1]
- 后4个元素反转：[5,6,7,1,2,3,4]
